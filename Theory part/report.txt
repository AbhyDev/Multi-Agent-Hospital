================================================================================
RV COLLEGE OF ENGINEERING®, BENGALURU-560059
(Autonomous Institution Affiliated to VTU, Belagavi)

DEPARTMENT OF COMPUTER SCIENCE AND ENGINEERING
================================================================================

AI HOSPITAL: A MULTI-AGENT MEDICAL CONSULTATION SYSTEM
WITH HYBRID DATABASE ARCHITECTURE

Mini - Project Report

Submitted by:

AKSHAT ARYA                    1RV23CS026
ABHYUDAY SHARMA                1RV23CS012

in partial fulfillment for the requirement of 5th Semester
DATABASE MANAGEMENT SYSTEMS (CD252IA)

Under the Guidance of:
Dr. Shweta Babu P., Professor, Dept. of CSE, RVCE

Academic Year 2025 - 2026

================================================================================
                              PAGE BREAK
================================================================================

RV COLLEGE OF ENGINEERING®, BENGALURU 560059
(Autonomous Institution Affiliated to VTU, Belagavi)

DEPARTMENT OF COMPUTER SCIENCE AND ENGINEERING

                              CERTIFICATE

Certified that the project work titled 'AI Hospital: A Multi-Agent Medical Consultation System with Hybrid Database Architecture' is carried out by Akshat Arya (1RV23CS026) and Abhyuday Sharma (1RV23CS012), who are bonafide students of R. V. College of Engineering, Bengaluru, in partial fulfillment of the curriculum requirement of 5th Semester Database Management Systems (CD252IA) Laboratory Mini Project during the academic year 2025-2026. It is certified that all corrections/suggestions indicated for the internal Assessment have been incorporated in the report. The report has been approved as it satisfies the academic requirements in all respect laboratory mini-project work prescribed by the institution.


Signature of Faculty In-charge                        Head of the Department
                                                      Dept. of CSE, RVCE


External Examination

Name of Examiners                                     Signature with date

1. _______________________________                    ___________________

2. _______________________________                    ___________________

================================================================================
                              PAGE BREAK
================================================================================

                           ACKNOWLEDGEMENT

We would like to express our sincere gratitude to Dr. Shweta Babu P., Professor, Department of Computer Science and Engineering, RV College of Engineering, for her invaluable guidance and constant encouragement throughout the development of this project.

We extend our heartfelt thanks to the Head of the Department, Computer Science and Engineering, for providing the necessary facilities and support.

We are grateful to the faculty members of the Department of Computer Science and Engineering for their constructive feedback and suggestions that helped improve our work.

We also thank our parents and friends for their unwavering support and motivation during this project.

Finally, we acknowledge the open-source community for providing the tools, libraries, and frameworks that made this project possible.


                                                      Akshat Arya (1RV23CS026)
                                                      Abhyuday Sharma (1RV23CS012)

================================================================================
                              PAGE BREAK
================================================================================

                              ABSTRACT

AI Hospital is a full-stack multi-agent medical consultation system that simulates realistic clinical workflows through intelligent agent orchestration. The system addresses a critical challenge in healthcare AI: managing both structured medical records (requiring ACID compliance and normalization) and unstructured AI conversation logs (requiring flexible schema) within a unified database architecture.

The project implements a hierarchical agent architecture where a General Physician (GP) agent triages patients and routes them to one of eight specialist agents (Ophthalmologist, Pediatrician, Orthopedist, Dermatologist, ENT, Gynecologist, Psychiatrist, Internal Medicine), each augmented with domain-specific Retrieval-Augmented Generation (RAG) capabilities.

The database design implements a hybrid approach:
• PostgreSQL handles structured medical records following Third Normal Form (3NF) normalization with six entities: Patient, Doctor, Consultation, LabOrder, LabResult, and MedicalReport.
• MongoDB stores unstructured conversation logs for analytics and audit trails.
• ChromaDB provides vector embeddings for RAG-based medical knowledge retrieval.

Key features include:
• Real-time communication via Server-Sent Events (SSE) for streaming agent responses
• JWT-based authentication for secure patient access
• SQL JOIN query implementation for patient history retrieval
• Complete referential integrity with CASCADE delete constraints

The system demonstrates that multi-agent AI systems can effectively model complex clinical decision-making while maintaining structured data persistence for regulatory compliance.

Keywords: Multi-agent systems, database normalization, hybrid database architecture, retrieval-augmented generation, medical AI

================================================================================
                              PAGE BREAK
================================================================================

                         TABLE OF CONTENTS

                                                              Page No.
Acknowledgement ....................................................... i
Abstract .............................................................. ii
Table of Contents .................................................... iii
List of Figures ...................................................... iv

1. Introduction ....................................................... 1
   1.1 Objective ...................................................... 1
   1.2 Scope .......................................................... 2

2. Software Requirement Specification ................................. 3
   2.1 Software Requirements .......................................... 3
   2.2 Hardware Requirements .......................................... 3
   2.3 Functional Requirements ........................................ 4
   2.4 Non-Functional Requirements .................................... 5

3. Entity Relationship Diagram ........................................ 6
   3.1 ER Diagram Description ......................................... 6
   3.2 Entities and Attributes ........................................ 7
   3.3 Relationships and Cardinalities ................................ 8

4. Data Flow Diagram .................................................. 9
   4.1 DFD Level 0 (Context Diagram) .................................. 9
   4.2 DFD Level 1 ................................................... 10

5. Relational Schema and Normalization ............................... 11
   5.1 Relational Schema ............................................. 11
   5.2 Normalization Analysis ........................................ 12
   5.3 SQL JOIN Query Implementation ................................. 14

6. NoSQL Database Design ............................................. 15
   6.1 MongoDB Schema ................................................ 15
   6.2 ChromaDB Vector Store ......................................... 16

7. Conclusion ........................................................ 17

8. References ........................................................ 18

9. Appendix: Snapshots ............................................... 19

================================================================================
                              PAGE BREAK
================================================================================

                          LIST OF FIGURES

Figure 1.1: System Architecture Overview .............................. 2
Figure 3.1: Entity-Relationship Diagram ............................... 6
Figure 4.1: DFD Level 0 (Context Diagram) ............................. 9
Figure 4.2: DFD Level 1 .............................................. 10
Figure 5.1: Relational Schema Diagram ................................ 11
Figure 6.1: Multi-Agent Workflow Diagram ............................. 16
Figure 9.1: Login Page ............................................... 19
Figure 9.2: Registration Page ........................................ 19
Figure 9.3: Chat Interface ........................................... 20
Figure 9.4: Tool Panel ............................................... 20
Figure 9.5: History Panel ............................................ 21

================================================================================
                              PAGE BREAK
================================================================================

                         CHAPTER 1: INTRODUCTION

Healthcare accessibility remains a critical challenge in resource-constrained environments where specialist availability is limited. According to the World Health Organization, approximately half the global population lacks access to essential health services, with specialist care being particularly scarce in rural and underserved regions. Virtual consultation systems powered by large language models (LLMs) offer a potential avenue for democratizing access to preliminary medical guidance.

Traditional chatbot-based health assistants operate as monolithic agents that attempt to handle all medical domains within a single model. This approach suffers from several limitations:
• Difficulty in maintaining specialized expertise across diverse medical fields
• Inability to model realistic clinical workflows involving multiple healthcare professionals
• Challenges in providing transparent reasoning that follows established diagnostic protocols
• Lack of structured data persistence for regulatory compliance

Real-world healthcare delivery involves coordinated interactions among multiple specialists. A patient presenting with symptoms might first consult a general practitioner who conducts initial triage, then be referred to an appropriate specialist, who may subsequently request laboratory tests from a pathologist or imaging studies from a radiologist.

INNOVATIVE COMPONENTS:
1. Multi-Agent Architecture: 11 specialized AI agents orchestrated via LangGraph state machine
2. Hybrid Database Design: Polyglot persistence combining PostgreSQL, MongoDB, and ChromaDB
3. Retrieval-Augmented Generation (RAG): Domain-specific vector stores for evidence-based responses
4. Real-Time Streaming: Server-Sent Events (SSE) for responsive consultations

1.1 OBJECTIVES

• To design and implement a multi-agent medical consultation system that simulates realistic clinical workflows with GP-to-Specialist routing
• To develop a normalized relational database schema (up to 3NF) for structured medical records ensuring data integrity and referential constraints
• To implement a hybrid database architecture combining RDBMS (PostgreSQL), Document DB (MongoDB), and Vector DB (ChromaDB)
• To create a patient history API demonstrating practical SQL JOIN operations across multiple tables
• To provide real-time consultation streaming via SSE for responsive user experience
• To integrate RAG capabilities for evidence-based medical responses grounded in authoritative literature

1.2 SCOPE

The scope of this project includes:
• Full-stack web application with React frontend and FastAPI backend
• 11 AI agents: 1 GP, 8 Specialists, 2 Helpers (Pathologist, Radiologist)
• 6 relational entities with referential integrity constraints
• JWT-based authentication for secure patient access
• Patient history retrieval with complex JOIN queries
• Conversation logging to MongoDB for audit trails
• 9 specialty-specific RAG knowledge bases

The system is intended for educational and demonstration purposes, simulating clinical workflows without providing actual medical advice.

================================================================================
                              PAGE BREAK
================================================================================

               CHAPTER 2: SOFTWARE REQUIREMENT SPECIFICATION

2.1 SOFTWARE REQUIREMENTS

+---------------------------+----------------------------------------+
| Component                 | Technology/Version                     |
+---------------------------+----------------------------------------+
| Operating System          | Windows 10/11, Linux, macOS            |
| Programming Language      | Python 3.11+, TypeScript               |
| Frontend Framework        | React 18, Vite                         |
| Backend Framework         | FastAPI                                |
| Agent Orchestration       | LangGraph, LangChain                   |
| Relational Database       | PostgreSQL 14+                         |
| Document Database         | MongoDB 7.0                            |
| Vector Database           | ChromaDB                               |
| LLM Provider              | Google Gemini 2.0-flash, Groq Qwen3-32B|
| Embedding Model           | BAAI/bge-large-en-v1.5                 |
| Authentication            | JWT (python-jose)                      |
| Real-time Communication   | SSE (sse-starlette)                    |
| ORM                       | SQLAlchemy                             |
| Package Manager           | uv (Python), npm (Node.js)             |
| Web Search API            | Tavily                                 |
+---------------------------+----------------------------------------+

2.2 HARDWARE REQUIREMENTS

MINIMUM REQUIREMENTS:
+---------------------------+----------------------------------------+
| Component                 | Specification                          |
+---------------------------+----------------------------------------+
| Processor                 | Intel Core i5 / AMD Ryzen 5 or higher  |
| RAM                       | 8 GB minimum (16 GB recommended)       |
| Storage                   | 10 GB free disk space                  |
| Network                   | Stable internet connection for LLM APIs|
| Display                   | 1280 x 720 resolution minimum          |
+---------------------------+----------------------------------------+

RECOMMENDED REQUIREMENTS:
+---------------------------+----------------------------------------+
| Component                 | Specification                          |
+---------------------------+----------------------------------------+
| Processor                 | Intel Core i7 / AMD Ryzen 7            |
| RAM                       | 16 GB or higher                        |
| Storage                   | 20 GB SSD                              |
| GPU                       | Optional (CPU-only embeddings used)    |
+---------------------------+----------------------------------------+

================================================================================
                              PAGE BREAK
================================================================================

2.3 FUNCTIONAL REQUIREMENTS

MODULE 1: AUTHENTICATION MODULE
• FR1.1: System shall allow patients to register with email, password, name, age, and gender
• FR1.2: System shall hash passwords using bcrypt before storage
• FR1.3: System shall authenticate patients and issue JWT tokens
• FR1.4: System shall validate tokens for protected endpoints
• FR1.5: System shall support logout by client-side token removal

MODULE 2: CONSULTATION MODULE
• FR2.1: System shall initiate consultations with GP agent triage
• FR2.2: System shall collect patient symptoms via interactive Q&A
• FR2.3: System shall route patients to appropriate specialists based on symptom analysis
• FR2.4: System shall allow specialists to invoke helper agents (Pathologist, Radiologist)
• FR2.5: System shall generate final diagnostic reports with diagnosis and treatment

MODULE 3: DATABASE MODULE
• FR3.1: System shall create consultation records when GP compiles patient data
• FR3.2: System shall create lab orders when helper agents request tests
• FR3.3: System shall store lab results with findings
• FR3.4: System shall persist final medical reports
• FR3.5: System shall log complete conversation history to MongoDB

MODULE 4: HISTORY MODULE (SQL JOIN QUERIES)
• FR4.1: System shall retrieve patient consultations with medical reports (LEFT JOIN)
• FR4.2: System shall retrieve lab orders with results (INNER + LEFT JOIN)
• FR4.3: System shall retrieve complete medical history (4-table JOIN)
• FR4.4: System shall provide summary statistics with aggregation

MODULE 5: RAG MODULE
• FR5.1: System shall embed medical documents using BGE embeddings
• FR5.2: System shall perform semantic search on specialty-specific vector stores
• FR5.3: System shall synthesize responses based on retrieved context

2.4 NON-FUNCTIONAL REQUIREMENTS

• NFR1: PERFORMANCE - System shall stream responses in real-time via SSE
• NFR2: SECURITY - All passwords shall be hashed; JWTs shall expire after 120 minutes
• NFR3: SCALABILITY - Polyglot persistence allows independent scaling of each database
• NFR4: AVAILABILITY - System shall handle concurrent consultations with separate threads
• NFR5: USABILITY - Glassmorphism UI with responsive design for mobile/desktop
• NFR6: MAINTAINABILITY - Modular code structure with separation of concerns
• NFR7: DATA INTEGRITY - Referential constraints with CASCADE delete

================================================================================
                              PAGE BREAK
================================================================================

                 CHAPTER 3: ENTITY RELATIONSHIP DIAGRAM

3.1 ER DIAGRAM DESCRIPTION

The Entity-Relationship (ER) Diagram models the database structure for the AI Hospital system. The diagram represents six entities that capture the medical consultation workflow, from patient registration through consultation and final diagnosis.

The ER model follows these design principles:
• Each entity has a unique primary key (surrogate key pattern)
• Foreign keys establish referential integrity between related entities
• CASCADE delete constraints maintain consistency on deletions
• Relationships are clearly defined with cardinality notation (1:N, 1:1)

[INSERT FIGURE 3.1: er_diagram.png HERE]

Figure 3.1: Entity-Relationship Diagram showing six entities: Patient, Doctor, Consultation, Lab_Order, Lab_Result, and Medical_Report with their relationships.

3.2 ENTITIES AND ATTRIBUTES

ENTITY: PATIENT
+---------------+-------------+------------------+-------------------------+
| Attribute     | Data Type   | Constraint       | Description             |
+---------------+-------------+------------------+-------------------------+
| patient_id    | INTEGER     | PRIMARY KEY      | Unique patient ID       |
| email         | VARCHAR     | UNIQUE, NOT NULL | Login credential        |
| password      | VARCHAR     | NOT NULL         | Bcrypt hashed password  |
| name          | VARCHAR     | NOT NULL         | Patient full name       |
| age           | INTEGER     | NULL             | Patient age             |
| gender        | VARCHAR     | NULL             | Male/Female/Other       |
| created_at    | TIMESTAMP   | DEFAULT now()    | Registration timestamp  |
+---------------+-------------+------------------+-------------------------+

ENTITY: DOCTOR
+---------------+-------------+------------------+-------------------------+
| Attribute     | Data Type   | Constraint       | Description             |
+---------------+-------------+------------------+-------------------------+
| doctor_id     | INTEGER     | PRIMARY KEY      | Unique doctor ID        |
| name          | VARCHAR     | NOT NULL         | AI agent name           |
| specialty     | VARCHAR     | NOT NULL         | Medical specialty       |
+---------------+-------------+------------------+-------------------------+

ENTITY: CONSULTATION
+------------------+-------------+------------------+-------------------------+
| Attribute        | Data Type   | Constraint       | Description             |
+------------------+-------------+------------------+-------------------------+
| consultation_id  | INTEGER     | PRIMARY KEY      | Unique consultation ID  |
| patient_id       | INTEGER     | FOREIGN KEY      | References Patient      |
| status           | VARCHAR     | DEFAULT 'Active' | Active/Completed        |
| started_at       | TIMESTAMP   | DEFAULT now()    | Session start time      |
+------------------+-------------+------------------+-------------------------+

================================================================================
                              PAGE BREAK
================================================================================

ENTITY: LAB_ORDER
+------------------+-------------+------------------+-------------------------+
| Attribute        | Data Type   | Constraint       | Description             |
+------------------+-------------+------------------+-------------------------+
| order_id         | INTEGER     | PRIMARY KEY      | Unique order ID         |
| consultation_id  | INTEGER     | FOREIGN KEY      | References Consultation |
| test_name        | VARCHAR     | NOT NULL         | Name of diagnostic test |
| status           | VARCHAR     | DEFAULT 'Pending'| Pending/Complete        |
+------------------+-------------+------------------+-------------------------+

ENTITY: LAB_RESULT
+---------------+-------------+------------------+-------------------------+
| Attribute     | Data Type   | Constraint       | Description             |
+---------------+-------------+------------------+-------------------------+
| result_id     | INTEGER     | PRIMARY KEY      | Unique result ID        |
| order_id      | INTEGER     | FOREIGN KEY      | References Lab_Order    |
| findings      | TEXT        | NOT NULL         | Diagnostic findings     |
+---------------+-------------+------------------+-------------------------+

ENTITY: MEDICAL_REPORT
+------------------+-------------+------------------+-------------------------+
| Attribute        | Data Type   | Constraint       | Description             |
+------------------+-------------+------------------+-------------------------+
| report_id        | INTEGER     | PRIMARY KEY      | Unique report ID        |
| consultation_id  | INTEGER     | FOREIGN KEY      | References Consultation |
| diagnosis        | TEXT        | NOT NULL         | Final diagnosis         |
| treatment        | TEXT        | NOT NULL         | Treatment plan          |
+------------------+-------------+------------------+-------------------------+

3.3 RELATIONSHIPS AND CARDINALITIES

RELATIONSHIP 1: Patient HAS Consultation
• Cardinality: 1:N (One-to-Many)
• Description: One Patient can have MANY Consultations
• Participation: Total Participation of Consultation (every consultation belongs to a patient)
• Foreign Key: patient_id in Consultation references Patient.patient_id
• Constraint: ON DELETE CASCADE

RELATIONSHIP 2: Consultation INCLUDES Lab_Order
• Cardinality: 1:N (One-to-Many)
• Description: One Consultation can have MANY Lab_Orders (multiple tests)
• Participation: Total Participation of Lab_Order
• Foreign Key: consultation_id in Lab_Order references Consultation.consultation_id
• Constraint: ON DELETE CASCADE

RELATIONSHIP 3: Lab_Order GENERATES Lab_Result
• Cardinality: 1:1 (One-to-One)
• Description: One Lab_Order produces exactly ONE Lab_Result
• Participation: Total Participation of Lab_Result
• Foreign Key: order_id in Lab_Result references Lab_Order.order_id
• Constraint: ON DELETE CASCADE

RELATIONSHIP 4: Consultation PRODUCES Medical_Report
• Cardinality: 1:1 (One-to-One)
• Description: One Consultation generates ONE final Medical_Report
• Participation: Total Participation of Medical_Report
• Foreign Key: consultation_id in Medical_Report references Consultation.consultation_id
• Constraint: ON DELETE CASCADE

================================================================================
                              PAGE BREAK
================================================================================

                     CHAPTER 4: DATA FLOW DIAGRAM

Data Flow Diagrams (DFDs) model how data moves through the AI Hospital system at different abstraction levels. DFDs help visualize:
• External entities interacting with the system
• Processes that transform data
• Data stores that persist information
• Data flows between components

4.1 DFD LEVEL 0 (CONTEXT DIAGRAM)

The Level 0 DFD (Context Diagram) represents the entire AI Hospital system as a single process, showing interactions with external entities.

[INSERT FIGURE 4.1: DFD Level 0 Context Diagram]

+-------------------+                                    +-------------------+
|                   |   Registration/Login Request       |                   |
|     PATIENT       | ---------------------------------> |                   |
|   (External       |                                    |    AI HOSPITAL    |
|    Entity)        | <--------------------------------- |      SYSTEM       |
|                   |   Auth Token / Consultation        |    (Process)      |
+-------------------+         Response                   |                   |
                                                         |                   |
+-------------------+                                    |                   |
|                   |   LLM API Requests                 |                   |
|   LLM PROVIDER    | <--------------------------------- |                   |
|   (Gemini/Groq)   | ---------------------------------> |                   |
|                   |   Generated Responses              +-------------------+
+-------------------+                                            |
                                                                 |
                             +-----------------------------------+
                             |
                             v
+-------------------+  +-------------------+  +-------------------+
|   POSTGRESQL      |  |     MONGODB       |  |    CHROMADB       |
|   (Structured     |  |   (Conversation   |  |   (Vector         |
|    Records)       |  |     Logs)         |  |    Embeddings)    |
+-------------------+  +-------------------+  +-------------------+

DESCRIPTION:
• PATIENT: External entity that registers, logs in, and participates in consultations
• AI HOSPITAL SYSTEM: Central process handling all business logic
• LLM PROVIDER: External AI service (Gemini, Groq) for generating responses
• POSTGRESQL: Data store for structured medical records
• MONGODB: Data store for unstructured conversation logs
• CHROMADB: Data store for vector embeddings (RAG)

================================================================================
                              PAGE BREAK
================================================================================

4.2 DFD LEVEL 1

The Level 1 DFD decomposes the AI Hospital System into major sub-processes, showing internal data flows.

[INSERT FIGURE 4.2: DFD Level 1]

+---------------+                                           +---------------+
|   PATIENT     |                                           | LLM PROVIDER  |
+-------+-------+                                           +-------+-------+
        |                                                           |
        | Credentials                                               |
        v                                                           |
+-------+-------+     Patient Data    +----------------+            |
|  1.0 AUTH     |-------------------->|   POSTGRESQL   |            |
|  MODULE       |                     |    (D1)        |            |
+-------+-------+                     +-------+--------+            |
        |                                     ^                     |
        | JWT Token                           |                     |
        v                                     |                     |
+-------+-------+     Consultation    +-------+--------+            |
|  2.0 GP       |-------------------->|  Consultation  |            |
|  TRIAGE       |     Record          |    Table       |            |
+-------+-------+                     +----------------+            |
        |                                                           |
        | Route Decision                                            |
        v                                                           v
+-------+-------+     Query           +----------------+    +-------+-------+
|  3.0 SPEC-    |-------------------->|   CHROMADB     |    |  4.0 RAG      |
|  IALIST       |                     |    (D3)        |<-->|  RETRIEVAL    |
|  CONSULT      |<--------------------|                |    +---------------+
+-------+-------+     Context         +----------------+
        |
        | Lab Request                 +----------------+
        v                             |   Lab_Order    |
+-------+-------+-------------------->|   Lab_Result   |
|  5.0 HELPER   |     Results         |    Tables      |
|  AGENTS       |<--------------------|    (D1)        |
+-------+-------+                     +----------------+
        |
        | Findings                    +----------------+
        v                             | Medical_Report |
+-------+-------+-------------------->|    Table       |
|  6.0 REPORT   |     Final Report    |    (D1)        |
|  GENERATION   |                     +----------------+
+-------+-------+
        |
        | Complete Log                +----------------+
        +----------------------------->|   MONGODB      |
                                      |    (D2)        |
                                      +----------------+

PROCESS DESCRIPTIONS:

1.0 AUTH MODULE: Handles patient registration and JWT authentication
2.0 GP TRIAGE: Collects symptoms, creates consultation record, routes to specialist
3.0 SPECIALIST CONSULT: Domain-specific consultation with RAG support
4.0 RAG RETRIEVAL: Queries ChromaDB for relevant medical knowledge
5.0 HELPER AGENTS: Pathologist/Radiologist provide diagnostic support
6.0 REPORT GENERATION: Compiles final diagnosis and treatment plan

================================================================================
                              PAGE BREAK
================================================================================

              CHAPTER 5: RELATIONAL SCHEMA AND NORMALIZATION

5.1 RELATIONAL SCHEMA

The relational schema defines the structure of all tables in PostgreSQL, including primary keys, foreign keys, and constraints.

[INSERT FIGURE 5.1: Relational Schema Diagram - synopsis_er_diagram.png]

SCHEMA DEFINITION (SQL DDL):

CREATE TABLE patients (
    patient_id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    age INTEGER,
    gender VARCHAR(50),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE doctors (
    doctor_id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    specialty VARCHAR(255) NOT NULL
);

CREATE TABLE consultations (
    consultation_id SERIAL PRIMARY KEY,
    patient_id INTEGER NOT NULL REFERENCES patients(patient_id) ON DELETE CASCADE,
    status VARCHAR(50) DEFAULT 'Active',
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE lab_orders (
    order_id SERIAL PRIMARY KEY,
    consultation_id INTEGER NOT NULL REFERENCES consultations(consultation_id) ON DELETE CASCADE,
    test_name VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'Pending'
);

CREATE TABLE lab_results (
    result_id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES lab_orders(order_id) ON DELETE CASCADE,
    findings TEXT NOT NULL
);

CREATE TABLE medical_reports (
    report_id SERIAL PRIMARY KEY,
    consultation_id INTEGER NOT NULL REFERENCES consultations(consultation_id) ON DELETE CASCADE,
    diagnosis TEXT NOT NULL,
    treatment TEXT NOT NULL
);

================================================================================
                              PAGE BREAK
================================================================================

5.2 NORMALIZATION ANALYSIS

The database schema is analyzed against the three normal forms to ensure data integrity and minimize redundancy.

FIRST NORMAL FORM (1NF)

Definition: A relation is in 1NF if:
• All attributes contain only atomic (indivisible) values
• There are no repeating groups or arrays
• Each table has a defined primary key

Verification:
+------------------+--------------------------------------------------+--------+
| Table            | Verification                                     | Status |
+------------------+--------------------------------------------------+--------+
| patients         | All columns scalar (INTEGER, VARCHAR, TIMESTAMP) |   ✓    |
| doctors          | All columns scalar (INTEGER, VARCHAR)            |   ✓    |
| consultations    | All columns scalar, no arrays                    |   ✓    |
| lab_orders       | All columns scalar                               |   ✓    |
| lab_results      | findings is TEXT (single value, not array)       |   ✓    |
| medical_reports  | diagnosis, treatment are TEXT (single values)    |   ✓    |
+------------------+--------------------------------------------------+--------+

CONCLUSION: All tables satisfy 1NF. ✓

SECOND NORMAL FORM (2NF)

Definition: A relation is in 2NF if:
• It is in 1NF
• Every non-key attribute is fully functionally dependent on the ENTIRE primary key

Verification:
All tables use single-column surrogate primary keys (patient_id, doctor_id, consultation_id, order_id, result_id, report_id). With single-attribute keys, partial dependency is impossible by definition.

Example Analysis - PATIENTS table:
• Primary Key: patient_id
• Non-key attributes: email, password, name, age, gender, created_at
• All non-key attributes depend on the entire primary key (patient_id)
• No partial dependencies exist

CONCLUSION: All tables satisfy 2NF. ✓

THIRD NORMAL FORM (3NF)

Definition: A relation is in 3NF if:
• It is in 2NF
• No non-key attribute transitively depends on the primary key

Verification by Table:

PATIENTS: email, password, name, age, gender, created_at all depend ONLY on patient_id
• name does NOT depend on age (they are independent attributes)
• gender does NOT depend on name
• No transitive dependencies exist ✓

CONSULTATIONS: patient_id (FK), status, started_at depend ONLY on consultation_id
• status does NOT depend on started_at
• patient_id is a foreign key reference, not a transitive dependency ✓

LAB_ORDERS: consultation_id (FK), test_name, status depend ONLY on order_id ✓

LAB_RESULTS: order_id (FK), findings depend ONLY on result_id ✓

MEDICAL_REPORTS: consultation_id (FK), diagnosis, treatment depend ONLY on report_id
• treatment does NOT depend on diagnosis (they are independent outputs) ✓

CONCLUSION: All tables satisfy 3NF. ✓

================================================================================
                              PAGE BREAK
================================================================================

NORMALIZATION SUMMARY TABLE

+------------------+------+------+------+----------------------------------+
| Table            | 1NF  | 2NF  | 3NF  | Notes                            |
+------------------+------+------+------+----------------------------------+
| patients         |  ✓   |  ✓   |  ✓   | Atomic values, single PK         |
| doctors          |  ✓   |  ✓   |  ✓   | Simple structure                 |
| consultations    |  ✓   |  ✓   |  ✓   | FK is reference, not transitive  |
| lab_orders       |  ✓   |  ✓   |  ✓   | No redundancy                    |
| lab_results      |  ✓   |  ✓   |  ✓   | One-to-one with lab_orders       |
| medical_reports  |  ✓   |  ✓   |  ✓   | One-to-one with consultations    |
+------------------+------+------+------+----------------------------------+

5.3 SQL JOIN QUERY IMPLEMENTATION

The /history API router demonstrates practical SQL JOIN operations across the normalized schema.

ENDPOINT 1: GET /history/consultations (LEFT JOIN)

SELECT c.consultation_id, c.status, c.started_at,
       mr.diagnosis, mr.treatment
FROM consultations c
LEFT JOIN medical_reports mr ON c.consultation_id = mr.consultation_id
WHERE c.patient_id = :patient_id
ORDER BY c.started_at DESC;

Purpose: Retrieves all consultations with their reports (if available).
JOIN Type: LEFT JOIN includes consultations even without reports.

ENDPOINT 2: GET /history/lab-results (INNER + LEFT JOIN)

SELECT lo.order_id, lo.test_name, lo.status AS order_status,
       lr.findings, c.started_at AS consultation_date
FROM lab_orders lo
JOIN consultations c ON lo.consultation_id = c.consultation_id
LEFT JOIN lab_results lr ON lo.order_id = lr.order_id
WHERE c.patient_id = :patient_id
ORDER BY c.started_at DESC;

Purpose: Retrieves lab orders with results for a patient.
JOIN Type: INNER JOIN (consultations required) + LEFT JOIN (results may be pending).

ENDPOINT 3: GET /history/complete (4-TABLE JOIN)

SELECT c.consultation_id, c.status, c.started_at,
       mr.diagnosis, mr.treatment,
       lo.test_name, lo.status AS lab_status, lr.findings
FROM consultations c
LEFT JOIN medical_reports mr ON c.consultation_id = mr.consultation_id
LEFT JOIN lab_orders lo ON c.consultation_id = lo.consultation_id
LEFT JOIN lab_results lr ON lo.order_id = lr.order_id
WHERE c.patient_id = :patient_id
ORDER BY c.started_at DESC;

Purpose: Complete medical history joining 4 tables.

ENDPOINT 4: GET /history/summary (AGGREGATION WITH JOIN)

SELECT COUNT(DISTINCT c.consultation_id) as total_consultations,
       COUNT(DISTINCT lo.order_id) as total_lab_orders,
       COUNT(DISTINCT mr.report_id) as total_reports
FROM consultations c
LEFT JOIN lab_orders lo ON c.consultation_id = lo.consultation_id
LEFT JOIN medical_reports mr ON c.consultation_id = mr.consultation_id
WHERE c.patient_id = :patient_id;

Purpose: Summary statistics using COUNT with GROUP BY.

================================================================================
                              PAGE BREAK
================================================================================

                    CHAPTER 6: NoSQL DATABASE DESIGN

The system implements a polyglot persistence architecture with two NoSQL databases serving distinct purposes.

6.1 MONGODB SCHEMA (DOCUMENT DATABASE)

MongoDB stores unstructured conversation logs for audit trails and analytics. The flexible schema accommodates varying message structures from different agents.

COLLECTION: conversation_logs

{
  "_id": ObjectId("..."),
  "thread_id": "uuid-string",
  "patient_id": 123,
  "timestamp": ISODate("2025-01-15T10:30:00Z"),
  "messages": {
    "gp": [
      {"role": "system", "content": "You are a GP..."},
      {"role": "assistant", "content": "Hello, how can I help?"},
      {"role": "human", "content": "I have a headache..."}
    ],
    "specialist": [
      {"role": "system", "content": "You are an ENT..."},
      {"role": "assistant", "content": "Based on your symptoms..."}
    ],
    "pathologist": [],
    "radiologist": []
  },
  "patho_QnA": ["Patient shows elevated WBC..."],
  "radio_QnA": [],
  "current_report": ["Diagnosis: Sinusitis..."],
  "final_agent": "ENT"
}

DESIGN PATTERN: Aggregate Root

The MongoDB schema follows the Aggregate Root pattern from Domain-Driven Design:
• Aggregate Root: The document itself, identified by thread_id
• Aggregate Boundary: All message histories belong to a single consultation
• Invariant: Complete consultation must have GP messages and final agent

Benefits:
• One query retrieves entire consultation history
• No multi-document transactions required
• Clear consistency boundaries

INTEGRATION WITH RDBMS:

+------------------+       +------------------+
|   POSTGRESQL     |       |     MONGODB      |
|   Consultation   |<----->| conversation_logs|
|   (Master Record)|       | (Detailed Log)   |
+------------------+       +------------------+
      |
      | consultation_id links to thread_id
      |
      v
   Structured records           Unstructured logs
   (ACID compliant)             (Flexible schema)

================================================================================
                              PAGE BREAK
================================================================================

6.2 CHROMADB VECTOR STORE

ChromaDB stores vector embeddings for Retrieval-Augmented Generation (RAG), enabling evidence-based medical responses.

ARCHITECTURE:

+-------------------+      +-------------------+      +-------------------+
| Medical PDFs      | ---> | BGE Embedding     | ---> | ChromaDB          |
| (IntechOpen)      |      | Model             |      | Collections       |
+-------------------+      +-------------------+      +-------------------+

EMBEDDING MODEL: BAAI/bge-large-en-v1.5
• Dimension: 1024 vectors
• Optimized for retrieval tasks
• CPU-compatible (no GPU required)

SPECIALTY COLLECTIONS:

backend/vector_stores/
├── Ophthalmologist/    # Eye conditions, treatments
├── Dermatology/        # Skin disorders
├── ENT/                # Ear, nose, throat pathologies
├── Gynecology/         # Reproductive health
├── Internal Medicine/  # Systemic diseases
├── Orthopedics/        # Musculoskeletal disorders
├── Pathology/          # Lab diagnostics
├── Pediatrics/         # Child-specific conditions
└── Psychiatry/         # Mental health

KNOWLEDGE BASE STATISTICS:

+--------------------+------------+---------------------------+
| Specialty          | Documents  | Source Type               |
+--------------------+------------+---------------------------+
| Dermatology        | 11         | Textbook chapters         |
| ENT                | 13         | Clinical guidelines       |
| Gynecology         | 12         | Medical textbooks         |
| Internal Medicine  | 13         | Reference texts           |
| Ophthalmology      | 10         | Clinical manuals          |
| Orthopedics        | 12         | Treatment protocols       |
| Pathology          | 11         | Laboratory manuals        |
| Pediatrics         | 10         | Pediatric textbooks       |
| Psychiatry         | 10         | DSM-aligned resources     |
+--------------------+------------+---------------------------+

RAG QUERY FLOW:

1. Specialist agent invokes VectorRAG_Retrieval(query, specialty)
2. Query is embedded using BGE model
3. ChromaDB performs top-5 similarity search on specialty collection
4. Retrieved documents are concatenated as context
5. LLM synthesizes response based only on provided context
6. Response is returned to specialist agent

[INSERT FIGURE 6.1: agent_workflow.png - Multi-Agent Workflow Diagram]

================================================================================
                              PAGE BREAK
================================================================================

                         CHAPTER 7: CONCLUSION

This project successfully demonstrates the design and implementation of a multi-agent medical consultation system with a hybrid database architecture. The key achievements include:

1. MULTI-AGENT ARCHITECTURE: Implemented 11 specialized AI agents (1 GP, 8 Specialists, 2 Helpers) orchestrated via LangGraph state machine with conditional routing based on symptom analysis.

2. NORMALIZED DATABASE DESIGN: Developed a PostgreSQL schema with 6 entities (Patient, Doctor, Consultation, Lab_Order, Lab_Result, Medical_Report) satisfying Third Normal Form (3NF), ensuring data integrity and eliminating redundancy.

3. HYBRID DATABASE ARCHITECTURE: Successfully integrated three database technologies:
   • PostgreSQL for ACID-compliant structured records
   • MongoDB for flexible conversation log storage
   • ChromaDB for RAG-based medical knowledge retrieval

4. SQL JOIN IMPLEMENTATION: Created practical API endpoints demonstrating LEFT JOIN, INNER JOIN, multi-table JOINs, and aggregation queries across the normalized schema.

5. REAL-TIME STREAMING: Implemented Server-Sent Events (SSE) for responsive consultation experiences with live agent responses.

6. RAG INTEGRATION: Deployed domain-specific vector stores across 9 medical specialties, enabling evidence-based responses grounded in authoritative medical literature.

LIMITATIONS:
• No clinical validation against actual medical outcomes
• In-memory LangGraph checkpointing (does not persist across restarts)
• English-only knowledge bases
• No image analysis capabilities for radiological/dermatological agents

FUTURE WORK:
• Persistent LangGraph checkpointing with PostgreSQL
• Multi-modal input for image-based diagnosis
• Multilingual support for regional languages
• FHIR standard integration for EHR interoperability
• Blockchain notarization for tamper-proof medical reports

================================================================================
                              PAGE BREAK
================================================================================

                          CHAPTER 8: REFERENCES

[1] World Health Organization, "Universal Health Coverage," WHO Fact Sheet, 2023.

[2] X. Yang, A. Chen, P. Agrawal, et al., "Large language models for healthcare: A comprehensive benchmark," in Proc. NeurIPS, 2023.

[3] K. Singhal, S. Azizi, T. Tu, et al., "Large language models encode clinical knowledge," Nature, vol. 620, pp. 172-180, 2023.

[4] Y. Li, Z. Li, K. Zhang, et al., "ChatDoctor: A medical chat model fine-tuned on LLaMA Model using medical domain knowledge," arXiv preprint arXiv:2303.14070, 2023.

[5] Q. Wu, G. Bansal, J. Zhang, et al., "AutoGen: Enabling next-gen LLM applications via multi-agent conversation," arXiv preprint arXiv:2308.08155, 2023.

[6] LangChain, "LangGraph: Build stateful, multi-actor applications," Documentation, 2024.

[7] E. F. Codd, "A relational model of data for large shared data banks," Commun. ACM, vol. 13, no. 6, pp. 377-387, 1970.

[8] R. Elmasri and S. B. Navathe, "Fundamentals of Database Systems," 7th ed. Pearson, 2015.

[9] P. J. Sadalage and M. Fowler, "NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence," Addison-Wesley, 2012.

[10] P. Lewis, E. Perez, A. Piktus, et al., "Retrieval-augmented generation for knowledge-intensive NLP tasks," in Proc. NeurIPS, 2020, pp. 9459-9474.

[11] Chroma, "ChromaDB: The open-source embedding database," Documentation, 2023.

[12] S. Xiao, Z. Liu, P. Zhang, and N. Muennighoff, "C-Pack: Packaged resources to advance general Chinese embedding," arXiv preprint arXiv:2309.07597, 2023.

================================================================================
                              PAGE BREAK
================================================================================

                     CHAPTER 9: APPENDIX - SNAPSHOTS

[INSERT FIGURE 9.1: Login Page Screenshot]
Figure 9.1: Login page with glassmorphism styling and authentication form.

[INSERT FIGURE 9.2: Registration/Signup Page Screenshot]
Figure 9.2: Patient registration form with name, email, password, age, and gender fields.

[INSERT FIGURE 9.3: Chat Interface Screenshot]
Figure 9.3: Main consultation interface showing chat bubbles with agent identification, current agent status, and real-time message streaming.

[INSERT FIGURE 9.4: Tool Panel Screenshot]
Figure 9.4: Tool visualization panel showing agent tool invocations (ask_user, VectorRAG_Retrieval, add_report).

[INSERT FIGURE 9.5: History Panel Screenshot]
Figure 9.5: Patient medical history panel showing consultations with diagnosis, treatment, and lab results retrieved via SQL JOIN queries.

[INSERT FIGURE 9.6: Agent Routing Visualization]
Figure 9.6: Visual representation of GP routing to specialist agents (Ophthalmologist, ENT, etc.).

================================================================================
                              END OF REPORT
================================================================================
