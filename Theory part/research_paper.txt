\documentclass{ieeeaccess}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{booktabs}
\usepackage{multirow}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}
\fontsize{12}{14}\selectfont
\doi{10.1109/ACCESS.2025.0102000}

\title{AI Hospital: A Multi-Agent Medical Consultation System with Hybrid Database Architecture}
\author{\uppercase{Dr Shweta Babu P.}\authorrefmark{1},
\uppercase{Akshat Arya}\authorrefmark{2}, \uppercase{Abhyuday Sharma}\authorrefmark{3}}

\address[1]{Dept. Computer Science and Engineering (Professor, e-mail: shwetababup@rvce.edu.inn)}
\address[2]{Dept. Computer Science and Engineering (USN: 1RV23CS026, e-mail: akshatarya.cs23@rvce.edu.in)}
\address[3]{Dept. Computer Science and Engineering (USN: 1RV23CS012, e-mail: abhyudaysharma.cs23@rvce.edu.in)}
\tfootnote{This work was supported by RV College of Engineering, Bangalore, India}

\markboth
{Author \headeretal: AI Hospital: A Multi-Agent Medical Consultation System}
{Author \headeretal: AI Hospital: A Multi-Agent Medical Consultation System}

\begin{abstract}
Healthcare accessibility remains a critical challenge in resource-constrained environments where specialist availability is limited. We present AI Hospital, a full-stack multi-agent medical consultation system that simulates realistic clinical workflows through intelligent agent orchestration. The system employs a hierarchical agent architecture where a General Physician agent triages patients and routes them to one of eight specialist agents, each augmented with domain-specific Retrieval-Augmented Generation (RAG) capabilities. Our database design implements a hybrid approach: PostgreSQL handles structured medical records following Boyce-Codd Normal Form (BCNF) normalization, while MongoDB stores unstructured conversation logs for analytics and audit trails. Real-time communication between frontend and backend utilizes Server-Sent Events (SSE) for streaming agent responses. We implement six relational entities---Patient, Doctor, Consultation, LabOrder, LabResult, and MedicalReport---with referential integrity constraints ensuring data consistency. The RAG subsystem leverages ChromaDB vector stores with BGE embeddings across nine medical specialties, enabling evidence-based responses grounded in authoritative medical literature. Our architecture demonstrates that multi-agent systems can effectively model complex clinical decision-making processes while maintaining structured data persistence for regulatory compliance and unstructured storage for comprehensive audit logging.
\end{abstract}

\begin{keywords}
Multi-agent systems, medical AI, database normalization, retrieval-augmented generation, hybrid database architecture, real-time streaming
\end{keywords}

\titlepgskip=-21pt
\maketitle

%==============================================================================
\section{Introduction}
\label{sec:intro}
%==============================================================================
\PARstart{T}{he} integration of artificial intelligence into healthcare delivery has emerged as a promising approach to address global shortages in medical expertise. According to the World Health Organization, approximately half the global population lacks access to essential health services, with specialist care being particularly scarce in rural and underserved regions~\cite{who2023}. Virtual consultation systems powered by large language models (LLMs) offer a potential avenue for democratizing access to preliminary medical guidance.

Traditional chatbot-based health assistants operate as monolithic agents that attempt to handle all medical domains within a single model. This approach suffers from several limitations: difficulty in maintaining specialized expertise across diverse medical fields, inability to model realistic clinical workflows involving multiple healthcare professionals, and challenges in providing transparent reasoning that follows established diagnostic protocols~\cite{yang2023}.

Real-world healthcare delivery involves coordinated interactions among multiple specialists. A patient presenting with symptoms might first consult a general practitioner who conducts initial triage, then be referred to an appropriate specialist, who may subsequently request laboratory tests from a pathologist or imaging studies from a radiologist. Modeling this multi-stakeholder workflow requires an architectural paradigm that transcends single-agent designs.

Simultaneously, healthcare applications impose stringent requirements on data management. Structured patient records must adhere to normalization principles ensuring data integrity, while consultation transcripts require flexible storage for auditing and analytics. This dual requirement motivates hybrid database architectures combining relational and document-oriented approaches.

In this paper, we present AI Hospital, a comprehensive system addressing these challenges through:

\begin{enumerate}
    \item A \textbf{multi-agent architecture} implementing 11 specialized medical agents (1 GP, 8 specialists, 2 support specialists) orchestrated via a state machine with conditional routing.
    \item A \textbf{normalized relational schema} in Boyce-Codd Normal Form (BCNF) managing six entities: Patient, Doctor, Consultation, LabOrder, LabResult, and MedicalReport.
    \item A \textbf{hybrid database approach} combining PostgreSQL for structured medical records with MongoDB for conversation log persistence.
    \item \textbf{Retrieval-Augmented Generation} using domain-specific vector stores for evidence-based specialist consultations.
    \item \textbf{Real-time streaming} via Server-Sent Events enabling responsive user interactions during multi-turn consultations.
\end{enumerate}

The remainder of this paper is organized as follows. Section~\ref{sec:related} reviews related work in medical AI systems and database design for healthcare. Section~\ref{sec:architecture} presents the system architecture. Section~\ref{sec:database} details the database design and normalization analysis. Section~\ref{sec:agents} describes the multi-agent implementation. Section~\ref{sec:rag} covers the RAG subsystem. Section~\ref{sec:implementation} provides implementation specifics. Section~\ref{sec:discussion} discusses findings and limitations. Section~\ref{sec:conclusion} concludes with future directions.

%==============================================================================
\section{Related Work}
\label{sec:related}
%==============================================================================

\subsection{Medical Conversational AI}
Early medical chatbots relied on rule-based systems with predefined decision trees. ELIZA, developed in the 1960s, demonstrated that pattern-matching responses could create an illusion of understanding~\cite{weizenbaum1966}. Modern systems leverage transformer-based language models trained on medical corpora. Med-PaLM achieved expert-level performance on medical licensing examinations by fine-tuning large language models on clinical datasets~\cite{singhal2023}.

However, these systems typically operate as single agents without modeling the collaborative nature of clinical practice. ChatDoctor introduced retrieval-augmented approaches for medical dialogue~\cite{li2023chatdoctor}, while HuatuoGPT explored Chinese medical consultation~\cite{zhang2023huatuo}. Our work extends this line by implementing multiple specialized agents that collaborate through explicit message passing.

\subsection{Multi-Agent Systems in Healthcare}
Multi-agent systems (MAS) have been applied to healthcare for scheduling, resource allocation, and clinical decision support~\cite{isern2010}. Agent-based models have simulated disease spread and hospital workflows. Recent advances in LLM-based agents have enabled more sophisticated multi-agent architectures. AutoGen demonstrated that multiple LLM agents could collaborate on complex tasks through conversation~\cite{wu2023autogen}. LangGraph provides a framework for building stateful, multi-actor applications with LLMs~\cite{langgraph2024}.

Our system builds upon LangGraph to implement a medical consultation workflow where agents maintain separate conversation histories and route patients based on symptom analysis.

\subsection{Database Design for Healthcare Systems}
Healthcare information systems require careful database design to ensure data integrity, privacy compliance, and query efficiency. The relational model remains dominant for Electronic Health Records (EHR) due to its strong consistency guarantees and support for complex queries~\cite{codd1970}. Normalization reduces redundancy and prevents update anomalies. Healthcare databases typically achieve Third Normal Form (3NF) or Boyce-Codd Normal Form (BCNF)~\cite{elmasri2015}.

NoSQL databases have gained adoption for specific healthcare use cases. Document stores handle semi-structured clinical notes; time-series databases manage continuous patient monitoring data~\cite{kochhar2017}. Polyglot persistence---using multiple database technologies---has emerged as a pragmatic approach~\cite{sadalage2012}. Our system implements this pattern with PostgreSQL for structured records and MongoDB for conversation logs.

\subsection{Retrieval-Augmented Generation}
RAG combines retrieval systems with generative models to ground outputs in external knowledge~\cite{lewis2020}. For medical applications, RAG mitigates hallucination risks by anchoring responses in authoritative sources. MedRAG demonstrated improved factual accuracy on medical question-answering benchmarks~\cite{xiong2024}. Vector databases like ChromaDB and Pinecone enable efficient similarity search over embedded documents~\cite{chromadb2023}.

Our implementation creates specialty-specific vector stores, allowing each specialist agent to retrieve relevant medical literature for their domain.

%==============================================================================
\section{System Architecture}
\label{sec:architecture}
%==============================================================================

\subsection{High-Level Overview}
AI Hospital follows a three-tier architecture consisting of a React-based frontend, a FastAPI backend, and a data layer comprising PostgreSQL, MongoDB, and ChromaDB. Figure~\ref{fig:architecture} illustrates the component relationships.

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{system_architecture.png}
    \caption{System architecture showing frontend, backend, and data layer components. Solid lines indicate synchronous requests; dashed lines represent SSE streams.}
    \label{fig:architecture}
\end{figure}

\subsection{Frontend Layer}
The user interface is built with React 18 and TypeScript, utilizing Vite for development tooling. Key features include:

\begin{itemize}
    \item \textbf{Authentication}: JWT-based login and registration forms
    \item \textbf{Chat Interface}: Real-time message display with agent identification
    \item \textbf{Tool Visualization}: Panel showing agent tool invocations
    \item \textbf{SSE Consumer}: EventSource API for streaming responses
    \item \textbf{History Panel}: Patient medical history viewer with JOIN-based data retrieval
\end{itemize}

The UI employs glassmorphism styling with responsive layouts adapting to mobile and desktop viewports.

\subsection{Data Flow Diagrams}
Data Flow Diagrams (DFDs) model how data moves through the system at varying abstraction levels:

\begin{itemize}
    \item \textbf{Level 0 (Context Diagram)}: Shows the entire system as a single process with external entities---Patient, AI Agent System, and Database Layer.
    \item \textbf{Level 1}: Decomposes into major sub-processes: Authentication, Consultation Workflow, and Report Generation.
    \item \textbf{Level 2}: Further details Level 1 processes, such as GP triage routing logic, specialist-to-helper delegation, and database persistence operations.
\end{itemize}

The hierarchical DFD representation aids in understanding data transformations across system boundaries and supports requirement traceability.

\subsection{Backend Layer}
The backend uses FastAPI for high-performance asynchronous request handling. Core components include:

\begin{itemize}
    \item \textbf{Authentication Router}: Patient registration and JWT token issuance
    \item \textbf{Graph Router}: SSE endpoints for starting and resuming consultations
    \item \textbf{LangGraph Engine}: Stateful graph execution with checkpointing
    \item \textbf{Tool Definitions}: Custom tools for patient interaction, search, and reporting
\end{itemize}

SQLAlchemy provides ORM capabilities for PostgreSQL interaction, while PyMongo handles MongoDB operations.

\subsection{Data Layer}
The data layer implements polyglot persistence:

\begin{itemize}
    \item \textbf{PostgreSQL}: Structured medical records (patients, consultations, reports)
    \item \textbf{MongoDB}: Unstructured conversation logs with full message histories
    \item \textbf{ChromaDB}: Vector embeddings for RAG retrieval across nine specialties
\end{itemize}

This separation allows each database technology to be used for its strengths: PostgreSQL for ACID transactions and complex joins, MongoDB for flexible document storage, and ChromaDB for semantic similarity search.

%==============================================================================
\section{Database Design}
\label{sec:database}
%==============================================================================

\subsection{Entity-Relationship Model}
The relational schema comprises six entities modeling the medical consultation workflow. Figure~\ref{fig:er} presents the entity-relationship diagram, and Table~\ref{tab:entities} provides a comprehensive summary of all entities.

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{er_diagram.png}
    \caption{Entity-Relationship diagram showing six entities and their relationships. PK denotes primary key; FK denotes foreign key.}
    \label{fig:er}
\end{figure}

\begin{table*}[t]
\centering
\caption{Complete Entity Specifications for the AI Hospital Database Schema}
\label{tab:entities}
\begin{tabular}{llllp{5cm}}
\toprule
\textbf{Entity} & \textbf{Primary Key} & \textbf{Foreign Key} & \textbf{Attributes} & \textbf{Description} \\
\midrule
Patient & patient\_id & --- & email, password, name, age, gender, created\_at & Registered users who initiate consultations; email has unique constraint for authentication \\
\midrule
Doctor & doctor\_id & --- & name, specialty & AI agent personas representing medical specialists; seeded with 9 practitioners at startup \\
\midrule
Consultation & consultation\_id & patient\_id $\rightarrow$ Patient & status, started\_at & Medical consultation sessions; status tracks lifecycle (Active/Completed/Abandoned) \\
\midrule
LabOrder & order\_id & consultation\_id $\rightarrow$ Consultation & test\_name, status & Diagnostic test requests by Pathologist/Radiologist agents; status is Pending or Complete \\
\midrule
LabResult & result\_id & order\_id $\rightarrow$ LabOrder & findings & Diagnostic findings text from helper agents; one-to-one with LabOrder \\
\midrule
MedicalReport & report\_id & consultation\_id $\rightarrow$ Consultation & diagnosis, treatment & Final consultation output; one-to-one with Consultation when specialist completes workflow \\
\bottomrule
\end{tabular}
\end{table*}

The entities and their attributes are:

\textbf{Patient} (\underline{patient\_id}, email, password, name, age, gender, created\_at)
\begin{itemize}
    \item Primary key: patient\_id (auto-increment)
    \item Unique constraint: email
    \item Represents registered users of the system
\end{itemize}

\textbf{Doctor} (\underline{doctor\_id}, name, specialty)
\begin{itemize}
    \item Primary key: doctor\_id (auto-increment)
    \item Seeded with nine specialists (GP plus eight specialties)
    \item Represents AI agent personas
\end{itemize}

\textbf{Consultation} (\underline{consultation\_id}, patient\_id, status, started\_at)
\begin{itemize}
    \item Primary key: consultation\_id (auto-increment)
    \item Foreign key: patient\_id references Patient
    \item Status values: Active, Completed, Abandoned
\end{itemize}

\textbf{LabOrder} (\underline{order\_id}, consultation\_id, test\_name, status)
\begin{itemize}
    \item Primary key: order\_id (auto-increment)
    \item Foreign key: consultation\_id references Consultation
    \item Created when helper agents request diagnostic tests
\end{itemize}

\textbf{LabResult} (\underline{result\_id}, order\_id, findings)
\begin{itemize}
    \item Primary key: result\_id (auto-increment)
    \item Foreign key: order\_id references LabOrder
    \item Stores pathologist/radiologist findings
\end{itemize}

\textbf{MedicalReport} (\underline{report\_id}, consultation\_id, diagnosis, treatment)
\begin{itemize}
    \item Primary key: report\_id (auto-increment)
    \item Foreign key: consultation\_id references Consultation
    \item Final consultation output with diagnosis and treatment plan
\end{itemize}

\subsection{Relationship Cardinalities}
Table~\ref{tab:relationships} summarizes the relationships between entities.

\begin{table}[t]
\centering
\caption{Entity Relationships and Cardinalities}
\label{tab:relationships}
\begin{tabular}{lcc}
\toprule
\textbf{Relationship} & \textbf{Cardinality} & \textbf{Constraint} \\
\midrule
Patient -- Consultation & 1:N & CASCADE DELETE \\
Consultation -- LabOrder & 1:N & CASCADE DELETE \\
LabOrder -- LabResult & 1:1 & CASCADE DELETE \\
Consultation -- MedicalReport & 1:1 & CASCADE DELETE \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Normalization Analysis}
We demonstrate that the schema satisfies Boyce-Codd Normal Form (BCNF), the strongest practical normal form for relational databases.

\subsubsection{First Normal Form (1NF)}
A relation is in 1NF if all attributes contain only atomic (indivisible) values and there are no repeating groups.

\textbf{Verification}: All tables use scalar data types (Integer, String, Text, Timestamp). No array or composite types are used. Each cell contains a single value. \checkmark

\subsubsection{Second Normal Form (2NF)}
A relation is in 2NF if it is in 1NF and every non-key attribute is fully functionally dependent on the entire primary key.

\textbf{Verification}: All tables use single-column surrogate primary keys (patient\_id, doctor\_id, etc.). With single-attribute keys, partial dependency is impossible by definition. \checkmark

\subsubsection{Third Normal Form (3NF)}
A relation is in 3NF if it is in 2NF and no non-key attribute transitively depends on the primary key.

\textbf{Verification}: We examine each table for transitive dependencies:

\begin{itemize}
    \item \textbf{Patient}: name, age, gender depend only on patient\_id, not on each other
    \item \textbf{Consultation}: status, started\_at depend on consultation\_id; patient\_id is a foreign key, not a dependent attribute
    \item \textbf{LabOrder}: test\_name, status depend on order\_id
    \item \textbf{LabResult}: findings depends on result\_id
    \item \textbf{MedicalReport}: diagnosis, treatment depend on report\_id
\end{itemize}

No transitive dependencies exist. \checkmark

\subsubsection{Boyce-Codd Normal Form (BCNF)}
A relation is in BCNF if for every non-trivial functional dependency $X \rightarrow Y$, $X$ is a superkey.

\textbf{Verification}: The only determinants in our schema are the primary keys. For example, in Patient: patient\_id $\rightarrow$ \{email, password, name, age, gender, created\_at\}. Since patient\_id is the primary key (and thus a superkey), the BCNF condition is satisfied. The same applies to all other tables. \checkmark

\subsection{SQL JOIN Query Implementation}
To demonstrate practical database operations, we implemented a \texttt{/history} API router exposing four endpoints that utilize SQL JOIN queries:

\begin{table}[t]
\centering
\caption{History API Endpoints with JOIN Operations}
\label{tab:joins}
\begin{tabular}{p{2.8cm}p{4.5cm}}
\toprule
\textbf{Endpoint} & \textbf{JOIN Type} \\
\midrule
\texttt{/consultations} & LEFT JOIN (consultations $\leftrightarrow$ medical\_reports) \\
\texttt{/lab-results} & INNER + LEFT JOIN (3 tables) \\
\texttt{/complete} & Multi-table JOIN (4 tables) \\
\texttt{/summary} & Aggregation with JOINs \\
\bottomrule
\end{tabular}
\end{table}

The complete history endpoint demonstrates a 4-table LEFT JOIN:

\begin{verbatim}
SELECT c.consultation_id, c.status,
       mr.diagnosis, mr.treatment,
       lo.test_name, lr.findings
FROM consultations c
LEFT JOIN medical_reports mr 
  ON c.consultation_id = mr.consultation_id
LEFT JOIN lab_orders lo 
  ON c.consultation_id = lo.consultation_id
LEFT JOIN lab_results lr 
  ON lo.order_id = lr.order_id
WHERE c.patient_id = :patient_id
\end{verbatim}

This implementation provides patients with a consolidated view of their medical history while demonstrating JOIN operations across the normalized schema.

\subsection{NoSQL Schema: MongoDB}
The conversation\_logs collection stores complete consultation transcripts for auditing and analytics:

\begin{verbatim}
{
  "_id": ObjectId,
  "thread_id": "uuid-string",
  "patient_id": Integer,
  "timestamp": ISODate,
  "messages": {
    "gp": [{role, content}, ...],
    "specialist": [...],
    "pathologist": [...],
    "radiologist": [...]
  },
  "patho_QnA": [String],
  "radio_QnA": [String],
  "current_report": [String],
  "final_agent": String
}
\end{verbatim}

This document structure captures the complete state of agent conversations, enabling historical analysis and model improvement.

\subsection{Hybrid Database Justification}
The choice of polyglot persistence is motivated by the distinct requirements of structured versus unstructured data:

\begin{table}[t]
\centering
\caption{Database Selection Rationale}
\label{tab:dbchoice}
\begin{tabular}{p{2cm}p{2.5cm}p{2.5cm}}
\toprule
\textbf{Requirement} & \textbf{PostgreSQL} & \textbf{MongoDB} \\
\midrule
ACID compliance & Required for medical records & Not critical for logs \\
Schema flexibility & Fixed, normalized & Dynamic, nested \\
Query patterns & Complex joins & Document retrieval \\
Regulatory & Audit trails & Analytics \\
\bottomrule
\end{tabular}
\end{table}

\subsection{NoSQL Design: Aggregate Root Pattern}
The MongoDB schema follows the \textbf{Aggregate Root} pattern from Domain-Driven Design (DDD)~\cite{evans2004}. An aggregate is a cluster of domain objects treated as a single unit for data changes, with one entity designated as the aggregate root through which all external access occurs.

In our system, the \texttt{conversation\_logs} document represents the \textbf{Consultation Aggregate}:

\begin{itemize}
    \item \textbf{Aggregate Root}: The document itself, identified by \texttt{thread\_id}
    \item \textbf{Aggregate Boundary}: All message histories (GP, specialist, pathologist, radiologist) belong to a single consultation session
    \item \textbf{Invariant}: A complete consultation must have at least GP messages and a final agent designation
\end{itemize}

This design satisfies key aggregate constraints:

\begin{enumerate}
    \item \textbf{Transactional Consistency}: All conversation data is written atomically in a single document insert
    \item \textbf{Encapsulation}: Nested message arrays are only accessible through the root document
    \item \textbf{Identity}: The \texttt{thread\_id} (from LangGraph) uniquely identifies each aggregate instance
\end{enumerate}

By modeling conversations as aggregates, we achieve:
\begin{itemize}
    \item Natural read patterns---one query retrieves entire consultation history
    \item Simplified write operations---no multi-document transactions required
    \item Clear consistency boundaries---all related data changes together
\end{itemize}

%==============================================================================
\section{Multi-Agent Architecture}
\label{sec:agents}
%==============================================================================

\subsection{Agent Hierarchy}
The system implements a hierarchical agent structure managed by LangGraph's StateGraph. Figure~\ref{fig:agents} illustrates the agent workflow.

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{agent_workflow.png}
    \caption{Multi-agent workflow showing GP triage, specialist consultation, and helper integration. Solid arrows indicate routing decisions; dashed arrows represent tool invocations.}
    \label{fig:agents}
\end{figure}

\subsubsection{General Physician (GP) Agent}
The GP agent serves as the entry point for all consultations. Its responsibilities include:

\begin{enumerate}
    \item Greeting the patient and collecting symptoms via the \texttt{ask\_user} tool
    \item Gathering demographic information (age, medical history)
    \item Compiling a triage summary via \texttt{Patient\_data\_report}
    \item Routing to the appropriate specialist based on symptom analysis
\end{enumerate}

\subsubsection{Specialist Agents}
Eight specialist agents handle domain-specific consultations:

\begin{itemize}
    \item \textbf{Ophthalmologist}: Eye conditions, vision problems
    \item \textbf{Pediatrician}: Child-specific health issues
    \item \textbf{Orthopedist}: Musculoskeletal conditions
    \item \textbf{Dermatologist}: Skin disorders
    \item \textbf{ENT}: Ear, nose, and throat problems
    \item \textbf{Gynecologist}: Women's reproductive health
    \item \textbf{Psychiatrist}: Mental health conditions
    \item \textbf{Internal Medicine}: Complex systemic diseases
\end{itemize}

Each specialist can invoke helper agents (Pathologist, Radiologist) for diagnostic support.

\subsubsection{Helper Agents}
Two support agents provide diagnostic capabilities:

\begin{itemize}
    \item \textbf{Pathologist}: Analyzes laboratory test results
    \item \textbf{Radiologist}: Interprets imaging studies
\end{itemize}

Helpers return findings to the requesting specialist, who incorporates them into the final diagnosis.

\subsection{State Management}
LangGraph maintains conversation state across agent transitions using a TypedDict structure:

\begin{verbatim}
class AgentState(TypedDict):
    messages: Sequence[BaseMessage]
    specialist_messages: Sequence
                    [BaseMessage]
    patho_messages: Sequence
                [BaseMessage]
    radio_messages: Sequence
                [BaseMessage]
    patho_QnA: list[str]
    radio_QnA: list[str]
    next_agent: list[str]
    current_report: list[str]
    current_agent: str
    consultation_id: Optional[int]
    patient_id: Optional[int]
\end{verbatim}

Separate message lists enable parallel conversation threads with specialists and helpers.

\subsection{Tool Definitions}
Agents interact with the system through five custom tools:

\begin{table}[t]
\centering
\caption{Agent Tool Specifications}
\label{tab:tools}
\begin{tabular}{p{2.5cm}p{4.5cm}}
\toprule
\textbf{Tool} & \textbf{Function} \\
\midrule
\texttt{ask\_user} & Pauses graph execution to collect patient input \\
\texttt{Patient\_data\_report} & Creates consultation record in PostgreSQL \\
\texttt{add\_report} & Saves findings as LabResult or MedicalReport \\
\texttt{VectorRAG\_Retrieval} & Queries specialty-specific vector store \\
\texttt{search\_internet} & Web search for supplementary information \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Routing Logic}
Conditional edges in the state graph determine agent transitions based on message content analysis:

\begin{algorithmic}[1]
\IF{last message contains tool calls}
    \IF{tool is ask\_user}
        \STATE Route to *\_AskUser (interrupt)
    \ELSE
        \STATE Route to *\_Tooler (execute tool)
    \ENDIF
\ELSIF{content mentions "pathologist"}
    \STATE Route to Pathologist
\ELSIF{content mentions "radiologist"}
    \STATE Route to Radiologist
\ELSIF{content contains "Final Report:"}
    \STATE Route to END
\ELSE
    \STATE Loop back to current agent
\ENDIF
\end{algorithmic}

%==============================================================================
\section{RAG Implementation}
\label{sec:rag}
%==============================================================================

\subsection{Vector Store Architecture}
Nine specialty-specific ChromaDB collections store embedded medical knowledge:

\begin{verbatim}
backend/vector_stores/
├── Ophthalmologist/
├── Dermatology/
├── ENT/
├── Gynecology/
├── Internal Medicine/
├── Orthopedics/
├── Pathology/
├── Pediatrics/
└── Psychiatry/
\end{verbatim}

\subsection{Embedding Model}
We employ the BGE-large-en-v1.5 embedding model from BAAI, which produces 1024-dimensional vectors optimized for retrieval tasks~\cite{bge2023}. The model runs on CPU to minimize hardware requirements.

\subsection{Retrieval Pipeline}
When a specialist invokes \texttt{VectorRAG\_Retrieval}:

\begin{enumerate}
    \item The query is embedded using BGE-large-en-v1.5
    \item ChromaDB performs top-5 similarity search
    \item Retrieved documents are concatenated as context
    \item A synthesis prompt instructs the LLM to answer based only on provided context
    \item The response is returned to the specialist agent
\end{enumerate}

This approach grounds specialist responses in authoritative medical literature, reducing hallucination risks.

\subsection{Knowledge Base: Open Source Medical Literature}
The RAG knowledge base is constructed from open-access medical textbooks and peer-reviewed literature sourced from \\textbf{IntechOpen}, a leading publisher of open-access scientific content. IntechOpen provides freely available medical textbooks and research chapters under Creative Commons licensing, ensuring legal compliance for embedding generation. Table~\\ref{tab:knowledge} summarizes the specialty-wise document distribution.

\begin{table}[t]
\centering
\caption{Knowledge Base Document Distribution by Specialty}
\label{tab:knowledge}
\begin{tabular}{lcc}
\toprule
\textbf{Specialty} & \textbf{Documents} & \textbf{Source Type} \\
\midrule
Dermatology & 11 & Textbook chapters, case studies \\
ENT & 13 & Clinical guidelines, textbooks \\
Gynecology & 12 & Medical textbooks, protocols \\
Internal Medicine & 13 & Reference texts, reviews \\
Ophthalmology & 10 & Clinical manuals, guides \\
Orthopedics & 12 & Treatment protocols, texts \\
Pathology & 11 & Laboratory manuals, atlases \\
Pediatrics & 10 & Pediatric textbooks \\
Psychiatry & 10 & DSM-aligned resources \\
\bottomrule
\end{tabular}
\end{table}

Using open-source medical literature ensures:
\begin{itemize}
    \item \textbf{Reproducibility}: No proprietary data dependencies
    \item \textbf{Currency}: Access to peer-reviewed medical knowledge
    \item \textbf{Compliance}: No copyright restrictions for embedding generation
\end{itemize}

%==============================================================================
\section{Implementation Details}
\label{sec:implementation}
%==============================================================================

\subsection{Technology Stack}
Table~\ref{tab:stack} summarizes the technologies used.

\begin{table}[t]
\centering
\caption{Technology Stack}
\label{tab:stack}
\begin{tabular}{ll}
\toprule
\textbf{Component} & \textbf{Technology} \\
\midrule
Frontend & React 18, TypeScript, Vite \\
Backend & FastAPI, Python 3.11 \\
Agent Framework & LangGraph, LangChain \\
LLM & Google Gemini 2.0-flash, Groq Qwen3-32B \\
Relational DB & PostgreSQL 14 \\
Document DB & MongoDB 7.0 \\
Vector DB & ChromaDB \\
Embeddings & BAAI/bge-large-en-v1.5 \\
Authentication & JWT (python-jose) \\
Real-time & SSE (sse-starlette) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Streaming Protocol}
SSE events follow a structured format enabling frontend state management:

\begin{verbatim}
thread   -> {thread_id}
message  -> {content, speaker, 
            current_agent}
tool     -> {id, name, args, agent}
ask_user -> {question, speaker}
final    -> {message, current_agent}
\end{verbatim}

The frontend maintains local state for chat history, current agent, and pending questions.

\subsection{Security Considerations}
\begin{itemize}
    \item Passwords hashed with bcrypt before storage
    \item JWT tokens with configurable expiration (default: 120 minutes)
    \item CORS restricted to known frontend origins
    \item Cascade deletion maintains referential integrity
\end{itemize}

%==============================================================================
\section{Discussion}
\label{sec:discussion}
%==============================================================================

\subsection{Design Decisions}
The multi-agent approach introduces complexity but provides significant benefits:

\begin{itemize}
    \item \textbf{Specialization}: Each agent's prompt focuses on domain expertise
    \item \textbf{Transparency}: Clear routing decisions mimic clinical workflows
    \item \textbf{Extensibility}: New specialties require only adding agent nodes
    \item \textbf{Auditability}: Separate message threads enable per-agent analysis
\end{itemize}

The hybrid database design balances consistency and flexibility. PostgreSQL's ACID properties ensure medical records remain consistent under concurrent access, while MongoDB's schema-less nature accommodates evolving conversation structures.

\subsection{Limitations}
Several limitations merit acknowledgment:

\begin{enumerate}
    \item \textbf{No Clinical Validation}: The system has not been validated against clinical outcomes
    \item \textbf{In-Memory Checkpointing}: Current LangGraph checkpointing does not persist across server restarts
    \item \textbf{Single Language}: Knowledge bases are English-only
    \item \textbf{No Image Analysis}: Radiologist/dermatologist agents cannot process actual images
\end{enumerate}

\subsection{Future Directions}
Planned enhancements include:

\begin{itemize}
    \item Persistent LangGraph checkpointing with PostgreSQL
    \item Multi-modal input for image-based diagnosis
    \item Multilingual support for regional languages
    \item Integration with FHIR standards for EHR interoperability
\end{itemize}

%==============================================================================
\section{Conclusion}
\label{sec:conclusion}
%==============================================================================
We presented AI Hospital, a multi-agent medical consultation system demonstrating the integration of LLM-based agents with hybrid database architecture. Key contributions include: (1) a hierarchical agent workflow with conditional routing across 11 medical agents; (2) a BCNF-normalized relational schema for structured medical records; (3) a polyglot persistence approach combining PostgreSQL and MongoDB; (4) domain-specific RAG for evidence-grounded specialist responses; and (5) real-time SSE streaming for responsive consultations.

The system illustrates how software engineering principles---normalization, separation of concerns, stateful orchestration---can be applied to medical AI applications. While clinical validation remains necessary before deployment, the architecture provides a foundation for future development of AI-assisted healthcare delivery systems.

%==============================================================================
\begin{thebibliography}{25}

\bibitem{who2023}
World Health Organization,
``Universal Health Coverage,''
\emph{WHO Fact Sheet}, 2023.

\bibitem{yang2023}
X. Yang, A. Chen, P. Agrawal, et al.,
``Large language models for healthcare: A comprehensive benchmark,''
in \emph{Proc. NeurIPS}, 2023.

\bibitem{weizenbaum1966}
J. Weizenbaum,
``ELIZA---a computer program for the study of natural language communication,''
\emph{Commun. ACM}, vol. 9, no. 1, pp. 36--45, 1966.

\bibitem{singhal2023}
K. Singhal, S. Azizi, T. Tu, et al.,
``Large language models encode clinical knowledge,''
\emph{Nature}, vol. 620, pp. 172--180, 2023.

\bibitem{li2023chatdoctor}
Y. Li, Z. Li, K. Zhang, et al.,
``ChatDoctor: A medical chat model fine-tuned on LLaMA Model using medical domain knowledge,''
\emph{arXiv preprint arXiv:2303.14070}, 2023.

\bibitem{zhang2023huatuo}
H. Zhang, J. Chen, F. Jiang, et al.,
``HuatuoGPT, towards taming language model to be a doctor,''
\emph{arXiv preprint arXiv:2305.15075}, 2023.

\bibitem{isern2010}
D. Isern and A. Moreno,
``A systematic literature review of agents applied in healthcare,''
\emph{J. Med. Syst.}, vol. 34, no. 5, pp. 911--932, 2010.

\bibitem{wu2023autogen}
Q. Wu, G. Bansal, J. Zhang, et al.,
``AutoGen: Enabling next-gen LLM applications via multi-agent conversation,''
\emph{arXiv preprint arXiv:2308.08155}, 2023.

\bibitem{langgraph2024}
LangChain,
``LangGraph: Build stateful, multi-actor applications,''
\emph{Documentation}, 2024.

\bibitem{codd1970}
E. F. Codd,
``A relational model of data for large shared data banks,''
\emph{Commun. ACM}, vol. 13, no. 6, pp. 377--387, 1970.

\bibitem{elmasri2015}
R. Elmasri and S. B. Navathe,
\emph{Fundamentals of Database Systems}, 7th ed.
Pearson, 2015.

\bibitem{kochhar2017}
S. Kochhar and A. Gupta,
``NoSQL databases for healthcare data analytics,''
in \emph{Proc. ICACCI}, 2017, pp. 1668--1673.

\bibitem{sadalage2012}
P. J. Sadalage and M. Fowler,
\emph{NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence}.
Addison-Wesley, 2012.

\bibitem{evans2004}
E. Evans,
\emph{Domain-Driven Design: Tackling Complexity in the Heart of Software}.
Addison-Wesley, 2004.

\bibitem{lewis2020}
P. Lewis, E. Perez, A. Piktus, et al.,
``Retrieval-augmented generation for knowledge-intensive NLP tasks,''
in \emph{Proc. NeurIPS}, 2020, pp. 9459--9474.

\bibitem{xiong2024}
G. Xiong, Q. Jin, Z. Lu, and A. Zhang,
``MedRAG: A benchmark for retrieval-augmented generation in medical question answering,''
\emph{arXiv preprint arXiv:2402.13178}, 2024.

\bibitem{chromadb2023}
Chroma,
``ChromaDB: The open-source embedding database,''
\emph{Documentation}, 2023.

\bibitem{bge2023}
S. Xiao, Z. Liu, P. Zhang, and N. Muennighoff,
``C-Pack: Packaged resources to advance general Chinese embedding,''
\emph{arXiv preprint arXiv:2309.07597}, 2023.

\bibitem{vaswani2017}
A. Vaswani, N. Shazeer, N. Parmar, et al.,
``Attention is all you need,''
in \emph{Proc. NeurIPS}, 2017, pp. 5998--6008.

\bibitem{kingma2015}
D. P. Kingma and J. Ba,
``Adam: A method for stochastic optimization,''
in \emph{Proc. ICLR}, 2015.

\bibitem{hochreiter1997}
S. Hochreiter and J. Schmidhuber,
``Long short-term memory,''
\emph{Neural Comput.}, vol. 9, no. 8, pp. 1735--1780, 1997.

\bibitem{devlin2019}
J. Devlin, M. Chang, K. Lee, and K. Toutanova,
``BERT: Pre-training of deep bidirectional transformers for language understanding,''
in \emph{Proc. NAACL}, 2019, pp. 4171--4186.

\bibitem{brown2020}
T. Brown, B. Mann, N. Ryder, et al.,
``Language models are few-shot learners,''
in \emph{Proc. NeurIPS}, 2020, pp. 1877--1901.

\bibitem{touvron2023}
H. Touvron, T. Lavril, G. Izacard, et al.,
``LLaMA: Open and efficient foundation language models,''
\emph{arXiv preprint arXiv:2302.13971}, 2023.

\bibitem{chen2020}
M. Chen, J. Tworek, H. Jun, et al.,
``Evaluating large language models trained on code,''
\emph{arXiv preprint arXiv:2107.03374}, 2021.

\bibitem{thoppilan2022}
R. Thoppilan, D. De Freitas, J. Hall, et al.,
``LaMDA: Language models for dialog applications,''
\emph{arXiv preprint arXiv:2201.08239}, 2022.

\end{thebibliography}

\EOD
\end{document}
